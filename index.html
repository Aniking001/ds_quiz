<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures Quiz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.10/babel.min.js"></script>
</head>
<body class="bg-gradient-to-br from-blue-50 to-purple-100 flex justify-center items-center min-h-screen p-4">
    <div id="root"></div>
    <script type="text/babel">
        const questions = [
            {
                category: "Loop Detection",
                items: [
                    { question: "In a linked list, loop detection can be efficiently performed using:", options: ["Breadth-first search", "Depth-first search", "Floyd's Tortoise and Hare algorithm", "Dijkstra's algorithm"], answer: "Floyd's Tortoise and Hare algorithm" },
                    { question: "What is the time complexity of Floyd's Tortoise and Hare algorithm for loop detection in a linked list?", options: ["O(n)", "O(log n)", "O(n^2)", "O(1)"], answer: "O(n)" },
                    { question: "Which data structure is commonly used to implement loop detection in a linked list?", options: ["Array", "Stack", "Queue", "Hash table"], answer: "Hash table" },
                    { question: "In a linked list with a loop, what does Floyd's Tortoise and Hare algorithm help identify?", options: ["Length of the loop", "Starting point of the loop", "Both A and B", "None of the above"], answer: "Both A and B" },
                    { question: "What is the space complexity of Floyd's Tortoise and Hare algorithm?", options: ["O(1)", "O(n)", "O(log n)", "O(n^2)"], answer: "O(1)" },
                    { question: "Which of the following is NOT a step in Floyd's Tortoise and Hare algorithm?", options: ["Move the tortoise by one step", "Move the hare by one step", "Move the tortoise by two steps", "Move the hare by two steps"], answer: "Move the hare by two steps" },
                    { question: "What happens if the tortoise and the hare meet during Floyd's Tortoise and Hare algorithm?", options: ["The linked list has a loop", "The linked list is empty", "The linked list is sorted", "None of the above"], answer: "The linked list has a loop" },
                    { question: "Which of the following statements about loop detection is true?", options: ["Loop detection is only possible in circular linked lists", "Loop detection is not possible in singly linked lists", "Loop detection can be performed in both singly and doubly linked lists", "Loop detection is only possible in arrays"], answer: "Loop detection can be performed in both singly and doubly linked lists" },
                    { question: "What is the worst-case time complexity of hashing-based loop detection in a linked list?", options: ["O(n)", "O(log n)", "O(1)", "O(n^2)"], answer: "O(n)" },
                    { question: "What happens if the hare reaches the end of the linked list during Floyd's Tortoise and Hare algorithm?", options: ["The linked list has a loop", "The linked list is empty", "The linked list is sorted", "None of the above"], answer: "None of the above" }
                ]
            },
            {
                category: "Sort the Bitonic DLL",
                items: [
                    { question: "What does 'bitonic' mean in the context of a doubly linked list (DLL)?", options: ["It refers to a DLL with both ascending and descending parts.", "It refers to a DLL with only ascending order.", "It refers to a DLL with only descending order.", "It refers to a DLL with random order."], answer: "It refers to a DLL with both ascending and descending parts." },
                    { question: "Which sorting algorithm is commonly used to sort a bitonic doubly linked list?", options: ["Quick Sort", "Merge Sort", "Bubble Sort", "Insertion Sort"], answer: "Merge Sort" },
                    { question: "In a bitonic doubly linked list, what is the time complexity of sorting using Merge Sort?", options: ["O(n log n)", "O(n^2)", "O(n)", "O(log n)"], answer: "O(n log n)" },
                    { question: "Which of the following is a characteristic of a bitonic doubly linked list?", options: ["It has all elements in ascending order.", "It has all elements in descending order.", "It has alternating ascending and descending order.", "It has a single element."], answer: "It has alternating ascending and descending order." },
                    { question: "What is the purpose of sorting a bitonic doubly linked list?", options: ["To rearrange the elements in descending order.", "To rearrange the elements in ascending order.", "To convert it into a circular linked list.", "To remove duplicate elements."], answer: "To rearrange the elements in ascending order." },
                    { question: "Which step is NOT involved in sorting a bitonic doubly linked list using Merge Sort?", options: ["Divide the list into sublists", "Merge the sorted sublists", "Perform binary search", "Recursively sort the sublists"], answer: "Perform binary search" },
                    { question: "What is the worst-case time complexity of sorting a bitonic doubly linked list using Merge Sort?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], answer: "O(n log n)" },
                    { question: "Which of the following algorithms is NOT suitable for sorting a bitonic doubly linked list?", options: ["Quick Sort", "Merge Sort", "Bubble Sort", "Insertion Sort"], answer: "Bubble Sort" },
                    { question: "Which of the following statements about bitonic doubly linked lists is true?", options: ["They can only have one ascending and one descending portion.", "They can have multiple ascending and descending portions.", "They are always sorted in ascending order.", "They cannot contain duplicate elements."], answer: "They can have multiple ascending and descending portions." },
                    { question: "What is the space complexity of Merge Sort when applied to a bitonic doubly linked list?", options: ["O(n)", "O(n^2)", "O(log n)", "O(1)"], answer: "O(n)" }
                ]
            },
            {
                category: "Segregate Even & Odd Nodes in a Linked List",
                items: [
                    { question: "Which of the following is an efficient approach to segregate even and odd nodes in a linked list?", options: ["Bubble Sort", "Merge Sort", "Quick Sort", "Two-pointer technique"], answer: "Two-pointer technique" },
                    { question: "In the two-pointer technique for segregating even and odd nodes, how many pointers are used?", options: ["One", "Two", "Three", "Four"], answer: "Two" },
                    { question: "What is the time complexity of segregating even and odd nodes using the two-pointer technique?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], answer: "O(n)" },
                    { question: "Which of the following steps is NOT involved in segregating even and odd nodes using the two-pointer technique?", options: ["Initialize two pointers", "Traverse the linked list", "Swap even and odd nodes", "Reverse the linked list"], answer: "Reverse the linked list" },
                    { question: "In the two-pointer technique, what is the role of the second pointer while segregating even and odd nodes?", options: ["It points to the first even node encountered.", "It points to the last odd node encountered.", "It points to the last even node encountered.", "It points to the first odd node encountered."], answer: "It points to the last even node encountered." },
                    { question: "Which of the following linked list types is NOT suitable for segregating even and odd nodes?", options: ["Singly linked list", "Doubly linked list", "Circular linked list", "Bitonic linked list"], answer: "Bitonic linked list" },
                    { question: "What is the purpose of segregating even and odd nodes in a linked list?", options: ["To rearrange the elements in ascending order", "To remove duplicate elements", "To separate nodes with even and odd values", "To convert it into a circular linked list"], answer: "To separate nodes with even and odd values" },
                    { question: "Which of the following is a characteristic of the linked list after segregating even and odd nodes?", options: ["All even nodes appear before all odd nodes.", "All odd nodes appear before all even nodes.", "Even and odd nodes are alternately arranged.", "The order of nodes remains unchanged."], answer: "All even nodes appear before all odd nodes." },
                    { question: "What is the space complexity of segregating even and odd nodes using the two-pointer technique?", options: ["O(n)", "O(n^2)", "O(log n)", "O(1)"], answer: "O(1)" },
                    { question: "Which of the following algorithms is NOT suitable for segregating even and odd nodes in a linked list?", options: ["Two-pointer technique", "Hashing-based approach", "Breadth-first search", "Depth-first search"], answer: "Breadth-first search" }
                ]
            },
            {
                category: "Merge Sort for Doubly Linked List",
                items: [
                    { question: "What is the time complexity of Merge Sort for a doubly linked list?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], answer: "O(n log n)" },
                    { question: "Which step is NOT involved in Merge Sort for a doubly linked list?", options: ["Divide the list into sublists", "Merge the sorted sublists", "Perform binary search", "Recursively sort the sublists"], answer: "Perform binary search" },
                    { question: "What is the space complexity of Merge Sort for a doubly linked list?", options: ["O(n)", "O(n log n)", "O(log n)", "O(1)"], answer: "O(n)" },
                    { question: "In Merge Sort for a doubly linked list, how are the sublists merged?", options: ["Using a hash table", "Using a stack", "Using recursion", "Using iterative loops"], answer: "Using recursion" },
                    { question: "Which data structure is commonly used for implementing Merge Sort for a doubly linked list?", options: ["Array", "Stack", "Queue", "Linked list"], answer: "Linked list" },
                    { question: "Which of the following is a characteristic of Merge Sort for a doubly linked list?", options: ["It is an in-place sorting algorithm.", "It requires extra space proportional to the length of the list.", "It has a worst-case time complexity of O(n^2).", "It cannot handle linked lists with loops."], answer: "It requires extra space proportional to the length of the list." },
                    { question: "What happens in the base case of Merge Sort for a doubly linked list?", options: ["The list is divided into sublists of size 1.", "The list is already sorted.", "The list contains only one element.", "The list is empty."], answer: "The list contains only one element." },
                    { question: "Which step comes first in the Merge Sort algorithm for a doubly linked list?", options: ["Merge the sorted sublists", "Divide the list into sublists", "Recursively sort the sublists", "Identify the base case"], answer: "Divide the list into sublists" },
                    { question: "Which of the following statements about Merge Sort for a doubly linked list is true?", options: ["It has a worst-case time complexity of O(n).", "It requires extra space proportional to the square of the length of the list.", "It is an unstable sorting algorithm.", "It is not suitable for sorting linked lists."], answer: "It is not suitable for sorting linked lists." },
                    { question: "What is the advantage of Merge Sort for a doubly linked list compared to other sorting algorithms?", options: ["It has a lower space complexity.", "It has a higher time complexity.", "It is stable.", "It can handle large datasets efficiently."], answer: "It has a lower space complexity." }
                ]
            },
            {
                category: "Minimum Stack",
                items: [
                    { question: "What is the time complexity of the push, pop, top, and getMin operations in a minimum stack?", options: ["O(1) for all operations", "O(n) for all operations", "O(1) for push and pop, O(n) for top and getMin", "O(n) for push and pop, O(1) for top and getMin"], answer: "O(1) for all operations" },
                    { question: "Which data structure is typically used to implement a minimum stack?", options: ["Array", "Linked list", "Queue", "Heap"], answer: "Linked list" },
                    { question: "In a minimum stack, what is the purpose of the getMin operation?", options: ["It returns the maximum element in the stack.", "It returns the minimum element in the stack.", "It returns the average of all elements in the stack.", "It returns the sum of all elements in the stack."], answer: "It returns the minimum element in the stack." },
                    { question: "Which of the following statements about a minimum stack is true?", options: ["It only allows positive integers to be stored.", "It cannot store duplicate elements.", "It maintains the minimum element at the top of the stack.", "It has a fixed size."], answer: "It maintains the minimum element at the top of the stack." },
                    { question: "What happens when the pop operation is called on an empty minimum stack?", options: ["It returns the minimum element in the stack.", "It removes the minimum element from the stack.", "It returns an error or throws an exception.", "It does nothing."], answer: "It returns an error or throws an exception." },
                    { question: "Which operation is responsible for maintaining the minimum element in a minimum stack?", options: ["push", "pop", "top", "getMin"], answer: "push" },
                    { question: "In a minimum stack, what is the time complexity of the getMin operation?", options: ["O(1)", "O(n)", "O(log n)", "O(n log n)"], answer: "O(1)" },
                    { question: "Which of the following statements about a minimum stack is false?", options: ["It can be implemented using an array.", "It supports constant-time operations for push, pop, top, and getMin.", "It may require additional space to store minimum elements.", "It always maintains the minimum element as the first element in the stack."], answer: "It always maintains the minimum element as the first element in the stack." },
                    { question: "What is the primary advantage of using a minimum stack?", options: ["It guarantees constant-time operations for all operations.", "It allows for efficient sorting of elements.", "It ensures that the minimum element is always accessible in constant time.", "It has a smaller memory footprint compared to other stack implementations."], answer: "It ensures that the minimum element is always accessible in constant time." },
                    { question: "Which of the following operations in a minimum stack has the highest time complexity?", options: ["push", "pop", "top", "getMin"], answer: "pop" }
                ]
            },
            {
                category: "The Celebrity Problem",
                items: [
                    { question: "In the celebrity problem, a celebrity is a person who:", options: ["Is widely known and admired", "Is famous for their achievements", "Is known by everyone but knows no one", "Is known by everyone and knows everyone"], answer: "Is known by everyone but knows no one" },
                    { question: "Which data structure is commonly used to solve the celebrity problem?", options: ["Array", "Stack", "Queue", "Graph"], answer: "Graph" },
                    { question: "In the celebrity problem, what is the objective of the algorithm?", options: ["To find the most famous person", "To find a person with the highest number of acquaintances", "To find the person who is known by everyone and knows no one", "To find a person with the most achievements"], answer: "To find the person who is known by everyone and knows no one" },
                    { question: "Which of the following statements about the celebrity problem is true?", options: ["There can be multiple celebrities in a group of people.", "A celebrity knows everyone in the group.", "The celebrity problem can be solved using only a stack.", "The solution to the celebrity problem always exists."], answer: "The solution to the celebrity problem always exists." },
                    { question: "What is the time complexity of the algorithm used to solve the celebrity problem?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], answer: "O(n)" },
                    { question: "In the algorithm for solving the celebrity problem, which step is NOT involved?", options: ["Checking if a candidate knows anyone", "Checking if everyone knows the candidate", "Checking if a candidate is known by everyone", "Checking if a candidate is known by no one"], answer: "Checking if a candidate knows anyone" },
                    { question: "Which of the following statements about the celebrity problem is false?", options: ["The celebrity problem can be solved in polynomial time.", "The solution to the celebrity problem may not be unique.", "The celebrity problem can be reduced to finding the minimum element in a list.", "The brute-force approach to the celebrity problem has a time complexity of O(n^2)."], answer: "The celebrity problem can be solved in polynomial time." },
                    { question: "In the context of the celebrity problem, what does it mean for a person to be a 'candidate'?", options: ["They are a well-known public figure.", "They are being considered as a potential celebrity.", "They are famous for their achievements.", "They have a large number of acquaintances."], answer: "They are being considered as a potential celebrity." },
                    { question: "Which approach is commonly used to solve the celebrity problem efficiently?", options: ["Brute-force search", "Dynamic programming", "Greedy algorithm", "Two-pointer technique"], answer: "Two-pointer technique" },
                    { question: "What is the space complexity of the algorithm used to solve the celebrity problem?", options: ["O(1)", "O(n)", "O(n^2)", "O(log n)"], answer: "O(1)" }
                ]
            },
            {
                category: "Iterative Tower of Hanoi",
                items: [
                    { question: "What is the minimum number of moves required to solve the Tower of Hanoi puzzle with 3 disks?", options: ["3", "5", "7", "9"], answer: "7" },
                    { question: "Which data structure is commonly used in the iterative approach to solving the Tower of Hanoi puzzle?", options: ["Array", "Stack", "Queue", "Linked list"], answer: "Stack" },
                    { question: "In the iterative Tower of Hanoi algorithm, how are the disks represented?", options: ["As integers", "As characters", "As nodes in a linked list", "As elements in an array"], answer: "As characters" },
                    { question: "What is the time complexity of the iterative Tower of Hanoi algorithm?", options: ["O(2^n)", "O(n^2)", "O(n log n)", "O(n)"], answer: "O(2^n)" },
                    { question: "What is the purpose of the Tower of Hanoi puzzle?", options: ["To sort a list of elements", "To find the shortest path in a graph", "To move a tower of disks from one peg to another, following specific rules", "To find the maximum sum of elements in an array"], answer: "To move a tower of disks from one peg to another, following specific rules" },
                    { question: "Which of the following statements about the Tower of Hanoi puzzle is true?", options: ["It can be solved using only a single peg.", "It can only be solved recursively.", "It has a unique solution for any number of disks.", "It becomes easier as the number of disks increases."], answer: "It has a unique solution for any number of disks." },
                    { question: "In the iterative Tower of Hanoi algorithm, which operation is performed first?", options: ["Move the top disk from source to auxiliary peg", "Move the top disk from source to destination peg", "Move the top disk from auxiliary to destination peg", "None of the above"], answer: "Move the top disk from source to auxiliary peg" },
                    { question: "What is the space complexity of the iterative Tower of Hanoi algorithm?", options: ["O(1)", "O(n)", "O(2^n)", "O(n^2)"], answer: "O(n)" },
                    { question: "Which of the following is NOT a rule of the Tower of Hanoi puzzle?", options: ["Only one disk can be moved at a time.", "A larger disk cannot be placed on top of a smaller disk.", "Disks can only be moved from source to destination peg.", "Disks must be stacked in ascending order of size on each peg."], answer: "Disks can only be moved from source to destination peg." },
                    { question: "What is the role of the auxiliary peg in the Tower of Hanoi puzzle?", options: ["It is where the final configuration is achieved.", "It serves as temporary storage during the recursive moves.", "It is where the smallest disk is initially placed.", "It is where the largest disk is initially placed."], answer: "It serves as temporary storage during the recursive moves." }
                ]
            },
            {
                category: "Stock Span Problem",
                items: [
                    { question: "What does the stock span represent in the stock span problem?", options: ["The difference between the current day's stock price and the previous day's stock price", "The total number of consecutive days the stock price has been increasing", "The ratio of the current day's stock price to the previous day's stock price", "The number of days required for the stock price to reach a certain threshold"], answer: "The total number of consecutive days the stock price has been increasing" },
                    { question: "Which data structure is commonly used to solve the stock span problem efficiently?", options: ["Array", "Stack", "Queue", "Linked list"], answer: "Stack" },
                    { question: "What is the time complexity of the algorithm used to solve the stock span problem?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], answer: "O(n)" },
                    { question: "In the stock span problem, how is the stock span calculated for each day?", options: ["By subtracting the current day's stock price from the previous day's stock price", "By dividing the current day's stock price by the previous day's stock price", "By counting the number of consecutive days the stock price has been increasing", "By finding the difference between the maximum and minimum stock prices over a certain period"], answer: "By counting the number of consecutive days the stock price has been increasing" },
                    { question: "What is the purpose of the stock span problem?", options: ["To predict future stock prices", "To identify profitable trading opportunities", "To analyze historical stock price data", "To efficiently calculate the stock span for each day"], answer: "To efficiently calculate the stock span for each day" },
                    { question: "Which of the following statements about the stock span problem is true?", options: ["It can only be solved using dynamic programming.", "It can be used to identify trends in stock price movements.", "It requires knowledge of future stock prices.", "It has a time complexity of O(n log n)."], answer: "It can be used to identify trends in stock price movements." },
                    { question: "In the stock span problem, what does the stock span value indicate?", options: ["The volatility of the stock", "The average stock price over a certain period", "The total number of consecutive days the stock price has been increasing", "The percentage change in stock price from the previous day"], answer: "The total number of consecutive days the stock price has been increasing" },
                    { question: "Which operation is performed first in the algorithm for solving the stock span problem using a stack?", options: ["Push", "Pop", "Peek", "Calculate stock span"], answer: "Push" },
                    { question: "What is the space complexity of the algorithm used to solve the stock span problem?", options: ["O(1)", "O(n)", "O(n^2)", "O(log n)"], answer: "O(n)" },
                    { question: "Which of the following statements about the stock span problem is false?", options: ["It is a type of financial analysis technique.", "It can be solved efficiently using a stack.", "It requires knowledge of future stock prices.", "It helps in understanding the behavior of stock prices over time."], answer: "It requires knowledge of future stock prices." }
                ]
            },
            {
                category: "Priority Queue using Doubly Linked List",
                items: [
                    { question: "Which data structure is commonly used as the underlying structure for implementing a priority queue?", options: ["Array", "Stack", "Queue", "Doubly linked list"], answer: "Array" },
                    { question: "What is the primary advantage of using a doubly linked list to implement a priority queue?", options: ["Constant-time insertion and deletion of elements", "Efficient memory utilization", "Ability to maintain elements in sorted order", "Ability to efficiently perform search operations"], answer: "Constant-time insertion and deletion of elements" },
                    { question: "In a priority queue implemented using a doubly linked list, how are elements arranged based on their priority?", options: ["Elements are arranged in ascending order of priority.", "Elements are arranged in descending order of priority.", "Elements are arranged randomly.", "Elements are arranged based on their insertion order."], answer: "Elements are arranged in ascending order of priority." },
                    { question: "What is the time complexity of the insert operation in a priority queue implemented using a doubly linked list?", options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"], answer: "O(1)" },
                    { question: "Which operation is typically used to remove the element with the highest priority from a priority queue implemented using a doubly linked list?", options: ["deleteMin", "deleteMax", "removeFirst", "removeLast"], answer: "deleteMin" },
                    { question: "In a priority queue implemented using a doubly linked list, how are elements with the same priority handled?", options: ["They are arranged in random order.", "They are arranged based on their insertion order.", "They are arranged in ascending order of value.", "They are arranged in descending order of value."], answer: "They are arranged based on their insertion order." },
                    { question: "Which of the following statements about priority queues implemented using doubly linked lists is true?", options: ["They have a fixed size.", "They cannot handle elements with equal priority.", "They support constant-time insertion and deletion operations.", "They always maintain elements in sorted order."], answer: "They support constant-time insertion and deletion operations." },
                    { question: "What is the primary disadvantage of using a doubly linked list to implement a priority queue?", options: ["Inefficient memory utilization", "Inability to handle elements with equal priority", "Inability to efficiently perform search operations", "Limited capacity"], answer: "Inefficient memory utilization" },
                    { question: "Which of the following operations is NOT typically supported by a priority queue implemented using a doubly linked list?", options: ["Insertion", "Deletion", "Search", "Retrieval of the element with the highest priority"], answer: "Search" },
                    { question: "What is the space complexity of a priority queue implemented using a doubly linked list?", options: ["O(1)", "O(n)", "O(log n)", "O(n^2)"], answer: "O(n)" }
                ]
            },
            {
                category: "Sort Without Extra Space",
                items: [
                    { question: "Which sorting algorithm is commonly used for sorting without extra space?", options: ["Merge Sort", "Quick Sort", "Insertion Sort", "Bubble Sort"], answer: "Quick Sort" },
                    { question: "What is the time complexity of sorting without extra space?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], answer: "O(n log n)" },
                    { question: "Which of the following statements about sorting without extra space is true?", options: ["It requires additional memory for storing intermediate results.", "It is always slower than traditional sorting algorithms.", "It is suitable for sorting large datasets.", "It is not suitable for sorting arrays."], answer: "It is suitable for sorting large datasets." },
                    { question: "In sorting without extra space, which approach is commonly used to minimize memory usage?", options: ["Divide and conquer", "Dynamic programming", "Greedy algorithm", "Backtracking"], answer: "Divide and conquer" },
                    { question: "What is the primary disadvantage of sorting without extra space?", options: ["Slower execution time", "Higher memory usage", "Limited applicability", "Complexity in implementation"], answer: "Complexity in implementation" },
                    { question: "Which of the following sorting algorithms can be adapted for sorting without extra space?", options: ["Bucket Sort", "Radix Sort", "Counting Sort", "All of the above"], answer: "All of the above" },
                    { question: "What is the space complexity of sorting without extra space?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], answer: "O(n)" },
                    { question: "Which step is NOT involved in sorting without extra space?", options: ["Divide the array into subarrays", "Merge the sorted subarrays", "Perform binary search", "Recursively sort the subarrays"], answer: "Perform binary search" },
                    { question: "Which of the following statements about sorting without extra space is false?", options: ["It is suitable for sorting arrays.", "It can be adapted for sorting linked lists.", "It is often used in embedded systems with limited memory.", "It requires careful handling of memory to avoid errors."], answer: "It is suitable for sorting arrays." },
                    { question: "What is the advantage of sorting without extra space over traditional sorting algorithms?", options: ["Lower time complexity", "Less memory usage", "Easier implementation", "Higher stability"], answer: "Less memory usage" }
                ]
            },
            {
                category: "Max Sliding Window",
                items: [
                    { question: "What is the Max Sliding Window problem?", options: ["Finding the maximum element in an array", "Determining the maximum number of elements that can fit in a window", "Finding the maximum element in a fixed-size subarray of a given array", "Sorting the array in descending order"], answer: "Finding the maximum element in a fixed-size subarray of a given array" },
                    { question: "Which data structure is commonly used to efficiently solve the Max Sliding Window problem?", options: ["Array", "Stack", "Queue", "Heap"], answer: "Heap" },
                    { question: "What is the primary purpose of the Max Sliding Window problem?", options: ["To find the minimum element in an array", "To determine the maximum number of elements that can fit in a window", "To find the maximum element in a fixed-size subarray of a given array", "To sort the array in descending order"], answer: "To find the maximum element in a fixed-size subarray of a given array" },
                    { question: "What is the time complexity of solving the Max Sliding Window problem using a heap?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], answer: "O(n log n)" },
                    { question: "In the Max Sliding Window problem, what does the sliding window refer to?", options: ["A window with a fixed number of elements", "A window that moves across the array", "A window containing the maximum element", "A window with elements sorted in descending order"], answer: "A window that moves across the array" },
                    { question: "What is the advantage of using a heap to solve the Max Sliding Window problem?", options: ["Lower time complexity", "Less memory usage", "Constant-time access to the maximum element", "Easier implementation"], answer: "Constant-time access to the maximum element" },
                    { question: "Which operation is performed first in the algorithm for solving the Max Sliding Window problem using a heap?", options: ["Insertion", "Deletion", "Peek", "Calculate the maximum element"], answer: "Insertion" },
                    { question: "What is the space complexity of solving the Max Sliding Window problem?", options: ["O(1)", "O(n)", "O(n log n)", "O(log n)"], answer: "O(n)" },
                    { question: "Which of the following statements about the Max Sliding Window problem is false?", options: ["It requires knowledge of future array elements.", "It can be solved efficiently using a heap.", "It involves maintaining a sliding window over the array.", "It can be used in applications such as real-time data processing."], answer: "It requires knowledge of future array elements." },
                    { question: "What is the purpose of solving the Max Sliding Window problem?", options: ["To find the maximum element in a given array", "To efficiently process data streams", "To sort elements within a window", "To find the average of elements in a window"], answer: "To efficiently process data streams" }
                ]
            },
            {
                category: "Stack Permutations",
                items: [
                    { question: "What is a stack permutation?", options: ["A permutation of elements in an array", "A permutation of elements in a stack", "A permutation of elements in a queue", "A permutation of elements in a doubly linked list"], answer: "A permutation of elements in a stack" },
                    { question: "Which of the following operations is NOT typically performed in stack permutations?", options: ["Push", "Pop", "Insertion", "Peek"], answer: "Insertion" },
                    { question: "What is the time complexity of determining whether a given permutation can be achieved using a stack?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], answer: "O(n)" },
                    { question: "In stack permutations, which condition must be satisfied for a given permutation to be achievable using a stack?", options: ["The permutation must be in ascending order.", "The permutation must be in descending order.", "The permutation must be a valid sequence of push and pop operations.", "The permutation must have an even number of elements."], answer: "The permutation must be a valid sequence of push and pop operations." },
                    { question: "Which data structure is commonly used to determine whether a given permutation can be achieved using a stack?", options: ["Array", "Stack", "Queue", "Linked List"], answer: "Stack" },
                    { question: "What is the primary purpose of solving the stack permutations problem?", options: ["To find the maximum element in an array", "To determine if a given permutation is achievable using a stack", "To sort elements within a stack", "To find the average of elements in a stack"], answer: "To determine if a given permutation is achievable using a stack" },
                    { question: "Which of the following statements about stack permutations is true?", options: ["Stack permutations involve rearranging elements in a queue.", "Stack permutations always result in a sorted stack.", "Stack permutations require knowledge of future elements.", "Stack permutations can be achieved using only insertion operations."], answer: "Stack permutations require knowledge of future elements." },
                    { question: "What is the space complexity of solving the stack permutations problem?", options: ["O(1)", "O(n)", "O(n log n)", "O(log n)"], answer: "O(n)" },
                    { question: "Which of the following statements about stack permutations is false?", options: ["It involves determining if a given permutation is achievable using a stack.", "It can be solved efficiently using dynamic programming.", "It requires knowledge of future elements in the permutation.", "It always results in a sorted stack."], answer: "It always results in a sorted stack." },
                    { question: "What is the advantage of solving the stack permutations problem?", options: ["It allows for efficient sorting of elements.", "It provides a way to determine if a given permutation is achievable using a stack.", "It simplifies the implementation of stack operations.", "It guarantees a specific order of elements in the stack."], answer: "It provides a way to determine if a given permutation is achievable using a stack." }
                ]
            },
            {
                category: "Linked List",
                items: [
                    { question: "Which of the following is NOT a type of linked list?", options: ["Singly linked list", "Doubly linked list", "Circular linked list", "Quadruple linked list"], answer: "Quadruple linked list" },
                    { question: "What is the time complexity of inserting a node at the beginning of a singly linked list?", options: ["O(1)", "O(log n)", "O(n)", "O(n^2)"], answer: "O(1)" },
                    { question: "Which of the following operations can be performed in constant time on a singly linked list?", options: ["Insertion at the end", "Deletion from the beginning", "Deletion from the end", "Traversal from beginning to end"], answer: "Deletion from the beginning" },
                    { question: "What is the advantage of a doubly linked list over a singly linked list?", options: ["Lower space complexity", "Faster traversal from beginning to end", "Ability to traverse in both directions", "Constant-time insertion at the end"], answer: "Ability to traverse in both directions" },
                    { question: "Which of the following statements about a circular linked list is true?", options: ["It does not contain any loops.", "It has a fixed size.", "The last node points to NULL.", "It can be used to implement a queue."], answer: "It can be used to implement a queue" },
                    { question: "What is the space complexity of a linked list?", options: ["O(1)", "O(log n)", "O(n)", "O(n^2)"], answer: "O(n)" },
                    { question: "Which of the following operations has the highest time complexity in a doubly linked list?", options: ["Insertion at the beginning", "Insertion at the end", "Deletion from the beginning", "Deletion from the end"], answer: "Deletion from the end" },
                    { question: "In a circular linked list, how can you identify the end of the list?", options: ["By checking if the last node points to NULL", "By checking if the first node points to NULL", "By traversing the entire list", "By checking the size of the list"], answer: "By checking if the last node points to NULL" },
                    { question: "Which of the following operations is NOT typically performed on a linked list?", options: ["Searching for an element", "Sorting the elements", "Insertion at a specific position", "Reversing the list"], answer: "Sorting the elements" },
                    { question: "What is the purpose of using a dummy node in a linked list?", options: ["To mark the end of the list", "To improve memory utilization", "To simplify insertion and deletion operations", "To avoid dealing with NULL pointers"], answer: "To avoid dealing with NULL pointers" }
                ]
            },
            {
                category: "Stack",
                items: [
                    { question: "What is a stack?", options: ["A linear data structure with a first-in-first-out (FIFO) policy", "A linear data structure with a last-in-first-out (LIFO) policy", "A hierarchical data structure", "A data structure used to implement recursion"], answer: "A linear data structure with a last-in-first-out (LIFO) policy" },
                    { question: "Which of the following operations is NOT typically performed on a stack?", options: ["Push", "Pop", "Delete", "Peek"], answer: "Delete" },
                    { question: "What is the time complexity of the push operation in a stack implemented using an array?", options: ["O(1)", "O(log n)", "O(n)", "O(n^2)"], answer: "O(1)" },
                    { question: "In a stack, which element can be accessed first?", options: ["The top element", "The bottom element", "Any random element", "None of the above"], answer: "The top element" },
                    { question: "Which of the following data structures is commonly used to implement a stack?", options: ["Array", "Linked list", "Queue", "Tree"], answer: "Array" },
                    { question: "What is the time complexity of the pop operation in a stack implemented using a linked list?", options: ["O(1)", "O(log n)", "O(n)", "O(n^2)"], answer: "O(1)" },
                    { question: "Which of the following applications does NOT use a stack?", options: ["Function calls and recursion", "Undo operation in text editors", "Breadth-first search", "Expression evaluation"], answer: "Breadth-first search" },
                    { question: "What happens when you try to pop an element from an empty stack?", options: ["It returns NULL", "It returns the last popped element", "It throws an exception", "It waits until an element is pushed"], answer: "It throws an exception" },
                    { question: "Which of the following statements about stacks is true?", options: ["A stack can be implemented using a queue.", "A stack follows the FIFO principle.", "A stack can only store elements of the same data type.", "A stack has a fixed size when implemented using an array."], answer: "A stack can be implemented using a queue." },
                    { question: "What is the primary advantage of using a stack?", options: ["It allows for efficient random access to elements.", "It provides a way to store and retrieve elements in a specific order.", "It has a lower space complexity compared to other data structures.", "It allows for efficient insertion and deletion at both ends."], answer: "It provides a way to store and retrieve elements in a specific order." }
                ]
            },
            {
                category: "Fibonacci Numbers",
                items: [
                    { question: "Which Java data type should be used to store large Fibonacci numbers to avoid overflow?", options: ["int", "long", "double", "BigInteger"], answer: "BigInteger" },
                    { question: "In the context of Fibonacci numbers, what is memoization used for?", options: ["Encrypting data", "Avoiding stack overflow errors", "Storing intermediate results to avoid redundant computations", "Reversing a sequence"], answer: "Storing intermediate results to avoid redundant computations" },
                    { question: "What is the primary disadvantage of using the naive recursive approach to compute Fibonacci numbers?", options: ["It requires extensive memory usage.", "It is difficult to implement.", "It has exponential time complexity.", "It cannot compute Fibonacci numbers accurately."], answer: "It has exponential time complexity." },
                    { question: "Which of the following is an example of a Fibonacci sequence-related problem?", options: ["Finding the largest element in an array", "Sorting a list of integers", "Computing the sum of prime numbers", "Counting ways to reach the nth step using 1 or 2 steps at a time"], answer: "Counting ways to reach the nth step using 1 or 2 steps at a time" },
                    { question: "What is the Fibonacci sequence term following 21?", options: ["34", "55", "89", "144"], answer: "34" },
                    { question: "What will be the output of fibonacci(6)?", options: ["5", "6", "8", "13"], answer: "8" },
                    { question: "Which of the following is the correct base case for computing Fibonacci numbers recursively?", options: ["fib(0) = 1, fib(1) = 1", "fib(0) = 0, fib(1) = 1", "fib(0) = 1, fib(1) = 2", "fib(0) = 0, fib(1) = 0"], answer: "fib(0) = 0, fib(1) = 1" },
                    { question: "What is the time complexity of the iterative dynamic programming approach to compute Fibonacci numbers?", options: ["O(n)", "O(log n)", "O(2^n)", "O(n^2)"], answer: "O(n)" },
                    { question: "Which data structure can be used to implement memoization for efficient Fibonacci computation?", options: ["Array", "Linked List", "Queue", "Stack"], answer: "Array" },
                    { question: "Which mathematical concept can be used to derive a closed-form expression for Fibonacci numbers, providing a direct formula for computing any term in the sequence?", options: ["Exponential function", "Geometric sequence", "Golden ratio", "Taylor series"], answer: "Golden ratio" }
                ]
            },
            {
                category: "HashMap and TreeMap",
                items: [
                    { question: "In what scenario might it be preferable to convert a HashMap to a TreeMap?", options: ["When you need constant-time performance for insertion and retrieval.", "When you need to preserve the order of insertion.", "When you need to sort the elements based on their natural ordering or a custom comparator.", "When memory utilization is the primary concern."], answer: "When you need to sort the elements based on their natural ordering or a custom comparator." },
                    { question: "In TreeMap, what does the comparator define?", options: ["The ordering of keys.", "The ordering of values.", "The structure of the tree.", "The hashing algorithm."], answer: "The ordering of keys." },
                    { question: "Which method is used to convert a HashMap to a TreeMap in the following code snippet?\nHashMap<String, Integer> hashMap = new HashMap<>();\n// Populate hashMap\nTreeMap<String, Integer> treeMap = new TreeMap<>(hashMap);", options: ["convertToTreeMap()", "treeMap.convertFromHashMap()", "TreeMap.fromHashMap()", "Constructor of TreeMap"], answer: "Constructor of TreeMap" },
                    { question: "Suppose you have a HashMap named studentGrades containing student names as keys and their respective grades as values. You want to convert this HashMap into a TreeMap sorted by student names. Which code snippet accomplishes this?", options: ["TreeMap<String, Integer> sortedGrades = new TreeMap<>(studentGrades);", "TreeMap<String, Integer> sortedGrades = new TreeMap<>(); sortedGrades.putAll(studentGrades);", "TreeMap<String, Integer> sortedGrades = new TreeMap<>(Comparator.reverseOrder()); sortedGrades.putAll(studentGrades);", "TreeMap<String, Integer> sortedGrades = new TreeMap<>(new Comparator<String>() { @Override public int compare(String s1, String s2) { return s1.compareTo(s2); } }); sortedGrades.putAll(studentGrades);"], answer: "TreeMap<String, Integer> sortedGrades = new TreeMap<>(); sortedGrades.putAll(studentGrades);" },
                    { question: "Which of the following scenarios would throw a NullPointerException when converting a HashMap to a TreeMap?", options: ["The HashMap contains null keys.", "The HashMap contains null values.", "The HashMap is empty.", "There is no scenario where a NullPointerException would occur during conversion."], answer: "The HashMap contains null keys." },
                    { question: "In the context of converting a HashMap to a TreeMap, what happens if the TreeMap constructor receives a HashMap containing duplicate keys?", options: ["The TreeMap retains the last value associated with each duplicate key.", "The TreeMap retains the first value associated with each duplicate key.", "It throws a DuplicateKeyException.", "It retains all key-value pairs, including duplicates."], answer: "The TreeMap retains the last value associated with each duplicate key." },
                    { question: "HashMap<String, Integer> hashMap = new HashMap<>(); hashMap.put(\"John\", 85); hashMap.put(\"Alice\", 90); hashMap.put(\"Bob\", 78); TreeMap<String, Integer> treeMap = new TreeMap<>(hashMap); What will happen if you attempt to add another entry to the hashMap after creating the treeMap?", options: ["The new entry will be automatically added to treeMap.", "It will throw a ConcurrentModificationException.", "The order of elements in treeMap will change accordingly.", "The new entry will only be available in hashMap, not in treeMap."], answer: "The new entry will only be available in hashMap, not in treeMap." },
                    { question: "Suppose you have a HashMap named wordCount containing words as keys and their respective frequencies as values. You want to convert this HashMap into a TreeMap sorted by word frequencies (values). Which code snippet accomplishes this?", options: ["TreeMap<String, Integer> sortedWordCount = new TreeMap<>(wordCount);", "TreeMap<String, Integer> sortedWordCount = new TreeMap<>(new Comparator<String>() { @Override public int compare(String s1, String s2) { return wordCount.get(s1).compareTo(wordCount.get(s2)); } }); sortedWordCount.putAll(wordCount);", "TreeMap<Integer, String> sortedWordCount = new TreeMap<>(); for (Map.Entry<String, Integer> entry : wordCount.entrySet()) { sortedWordCount.put(entry.getValue(), entry.getKey()); }", "TreeMap<Integer, String> sortedWordCount = new TreeMap<>(wordCount);"], answer: "TreeMap<Integer, String> sortedWordCount = new TreeMap<>(); for (Map.Entry<String, Integer> entry : wordCount.entrySet()) { sortedWordCount.put(entry.getValue(), entry.getKey()); }" },
                    { question: "Which data structure does TreeMap internally use for storing key-value pairs?", options: ["Hash table", "Linked list", "Red-black tree", "AVL tree"], answer: "Red-black tree" },
                    { question: "What is the time complexity of converting a HashMap to a TreeMap?", options: ["O(n log n)", "O(n)", "O(log n)", "O(1)"], answer: "O(n log n)" }
                ]
            },
            {
                category: "Longest Increasing Subsequence (LIS)",
                items: [
                    { question: "What is the time complexity of the dynamic programming solution for the Longest Increasing Subsequence (LIS) problem?", options: ["O(n)", "O(n^2)", "O(n log n)", "O(2^n)"], answer: "O(n^2)" },
                    { question: "Which of the following is NOT a correct statement about the Longest Increasing Subsequence (LIS) problem?", options: ["LIS can have multiple solutions.", "LIS is a variation of the longest common subsequence problem.", "The elements of the LIS need not be contiguous in the original sequence.", "LIS can be solved using only a greedy approach."], answer: "LIS can be solved using only a greedy approach." },
                    { question: "Which algorithm can be used to find the length of the Longest Increasing Subsequence (LIS) in O(n log n) time?", options: ["Breadth-First Search (BFS)", "Depth-First Search (DFS)", "Binary Search", "QuickSort"], answer: "Binary Search" },
                    { question: "What is the space complexity of the dynamic programming solution for the Longest Increasing Subsequence (LIS) problem?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(1)"], answer: "O(n)" },
                    { question: "Which data structure is commonly used to implement the dynamic programming solution for the Longest Increasing Subsequence (LIS) problem?", options: ["Array", "Linked List", "Stack", "Queue"], answer: "Array" },
                    { question: "Which of the following is a correct statement about the Longest Increasing Subsequence (LIS) problem?", options: ["LIS always includes the first element of the original sequence.", "LIS always includes the last element of the original sequence.", "LIS always includes both the first and last elements of the original sequence.", "None of the above."], answer: "None of the above." },
                    { question: "Which of the following algorithms is commonly used to find the Longest Increasing Subsequence (LIS)?", options: ["Depth-First Search (DFS)", "Breadth-First Search (BFS)", "Dynamic Programming (DP)", "Greedy Algorithm"], answer: "Dynamic Programming (DP)" },
                    { question: "Which of the following statements about the Longest Increasing Subsequence (LIS) problem is true?", options: ["LIS can be solved using brute-force enumeration", "The length of LIS can be greater than the length of the original sequence.", "LIS always starts and ends with the smallest and largest elements of the original sequence, respectively.", "The elements of LIS must be adjacent in the original sequence."], answer: "LIS can be solved using brute-force enumeration" },
                    { question: "What does the 'increasing' in Longest Increasing Subsequence (LIS) refer to?", options: ["The elements of the LIS are sorted in non-decreasing order.", "The elements of the LIS are sorted in strictly increasing order.", "The difference between consecutive elements of the LIS is always positive.", "The sum of elements in the LIS is always increasing."], answer: "The elements of the LIS are sorted in strictly increasing order." },
                    { question: "Find the longest increasing subsequence for the given sequence: {10, -10, 12, 9, 10, 15, 13, 14}", options: ["{10, 12, 15}", "{10, 12, 13, 14}", "{-10, 12, 13, 14}", "{-10, 9, 10, 13, 14}"], answer: "{-10, 9, 10, 13, 14}" }
                ]
            },
            {
                category: "Longest Bitonic Subsequence",
                items: [
                    { question: "What does the Longest Bitonic Subsequence problem find?", options: ["The longest subsequence with alternating elements.", "The longest subsequence with increasing elements followed by decreasing elements.", "The longest subsequence with decreasing elements followed by increasing elements.", "The longest subsequence with equal elements."], answer: "The longest subsequence with increasing elements followed by decreasing elements." },
                    { question: "Which of the following algorithms is commonly used to solve the Longest Bitonic Subsequence problem?", options: ["Breadth-First Search (BFS)", "Depth-First Search (DFS)", "Dynamic Programming (DP)", "Greedy Algorithm"], answer: "Dynamic Programming (DP)" },
                    { question: "What is the time complexity of the dynamic programming solution for the Longest Bitonic Subsequence problem?", options: ["O(n)", "O(n log n)", "O(2^n)", "O(n^2)"], answer: "O(n^2)" },
                    { question: "Which data structure is commonly used to implement the dynamic programming solution for the Longest Bitonic Subsequence problem?", options: ["Array", "Linked List", "Stack", "Queue"], answer: "Array" },
                    { question: "What is the space complexity of the dynamic programming solution for the Longest Bitonic Subsequence problem?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(1)"], answer: "O(n)" },
                    { question: "In Java, which data structure is often used to represent a sequence of elements?", options: ["Array", "ArrayList", "LinkedList", "Set"], answer: "ArrayList" },
                    { question: "What does the 'longest' in the Longest Bitonic Subsequence problem refer to?", options: ["The subsequence with the maximum sum of elements", "The subsequence with the maximum number of elements.", "The subsequence with the maximum product of elements.", "The subsequence with the maximum length."], answer: "The subsequence with the maximum length." },
                    { question: "Which of the following is a correct statement about the Longest Bitonic Subsequence problem?", options: ["It can only be solved using recursive techniques.", "It can be solved using a single-pass algorithm.", "It can be solved optimally using a greedy approach.", "It can have multiple bitonic subsequences of the same length."], answer: "It can have multiple bitonic subsequences of the same length." },
                    { question: "Which of the following approaches is used in dynamic programming solutions for the Longest Bitonic Subsequence problem?", options: ["Divide and Conquer", "Memoization", "Backtracking", "Greedy Technique"], answer: "Memoization" },
                    { question: "What is the main idea behind solving the Longest Bitonic Subsequence problem using dynamic programming?", options: ["Finding all possible subsequences and selecting the longest one", "Breaking the problem into smaller subproblems and storing their solutions to avoid recomputation.", "Sorting the sequence and finding the longest subsequence", "Using a greedy approach to iteratively construct the bitonic subsequence."], answer: "Breaking the problem into smaller subproblems and storing their solutions to avoid recomputation." }
                ]
            },
            {
                category: "Item Distribution",
                items: [
                    { question: "How many items can a person take of the same type at maximum?", options: ["1", "2", "3", "Unlimited"], answer: "2" },
                    { question: "What data structure is commonly used to represent the available items for distribution?", options: ["Array", "Linked List", "Stack", "Queue"], answer: "Array" },
                    { question: "What is the complexity of distributing items among people?", options: ["O(n)", "O(n^2)", "O(log n)", "O(1)"], answer: "O(n)" },
                    { question: "Which method can be used to check if a person can take more items of the same type?", options: ["checkAvailability()", "takeItem()", "canTakeMore()", "getMaxItems()"], answer: "canTakeMore()" },
                    { question: "How can you ensure each person gets a fair distribution of items?", options: ["By shuffling the items randomly", "By sorting the items alphabetically", "By distributing items in ascending order", "By distributing items in descending order"], answer: "By shuffling the items randomly" },
                    { question: "Which Java collection is suitable for shuffling items?", options: ["ArrayList", "HashSet", "TreeMap", "LinkedList"], answer: "ArrayList" },
                    { question: "What does the constraint 'cannot take more than two items of the same type' imply in a distribution problem?", options: ["Each person can only take two items in total", "Each person can only take up to two items of each type", "Each person can only take one item of each type", "Each person can take unlimited items of the same type"], answer: "Each person can only take up to two items of each type" },
                    { question: "Which approach is suitable for handling constraints in item distribution?", options: ["Divide and Conquer", "Backtracking", "Randomized algorithms", "Brute force"], answer: "Backtracking" },
                    { question: "What happens if a person tries to take more than two items of the same type?", options: ["Allowed", "Not allowed", "Depends on the situation", "None of the above"], answer: "Not allowed" },
                    { question: "In a scenario where there are more items than people, what approach can be used to ensure fair distribution?", options: ["Random distribution", "Round-robin distribution", "Priority-based distribution", "Weighted distribution"], answer: "Round-robin distribution" }
                ]
            },
            {
                category: "Subset Sum Problem",
                items: [
                    { question: "Which of the following should be the base case for the recursive solution of subset sum problem?", options: ["if(sum==0) return true;", "if(sum==0) return true; if (n ==0 && sum!= 0) return false;", "if (n ==0 && sum!= 0) return false;", "if(sum<0) return true; if (n ==0 && sum!= 0) return false;"], answer: "if(sum==0) return true; if (n ==0 && sum!= 0) return false;" },
                    { question: "Which of the following is not true about subset sum problem?", options: ["The recursive solution has a time complexity of O(2^n)", "There is no known solution that takes polynomial time", "The recursive solution is slower than dynamic programming solution", "The dynamic programming solution has a time complexity of O(n log n)"], answer: "The dynamic programming solution has a time complexity of O(n log n)" },
                    { question: "Dynamic programming solution of subset sum problem is faster than recursive solution in terms of", options: ["Time complexity", "Space complexity", "Both time and space complexity", "None of the above"], answer: "Time complexity" },
                    { question: "Subset sum problem is an example of", options: ["LCS problem", "NP-complete problem", "LPS problem", "None of the above"], answer: "NP-complete problem" },
                    { question: "What is the worst case time complexity of dynamic programming solution of the subset sum problem (sum=given subset sum)?", options: ["O(n)", "O(sum)", "O(n^2)", "O(sum*n)"], answer: "O(sum*n)" },
                    { question: "Which of the following is true about the time complexity of the recursive solution of the subset sum problem?", options: ["It has an exponential time complexity", "It has a linear time complexity", "It has a logarithmic time complexity", "It has a time complexity of O(n^2)"], answer: "It has an exponential time complexity" },
                    { question: "What is a subset sum problem?", options: ["Finding a subset of a set that has sum of elements equal to a given number", "Checking for the presence of a subset that has sum of elements equal to a given number and printing true or false based on the result", "Finding the sum of elements present in a set", "Finding the sum of all the subsets of a set"], answer: "Checking for the presence of a subset that has sum of elements equal to a given number and printing true or false based on the result" },
                    { question: "Under what condition any set A will be a subset of B?", options: ["If all elements of set B are also present in set A", "If all elements of set A are also present in set B", "If A contains more elements than B", "If B contains more elements than A"], answer: "If all elements of set A are also present in set B" },
                    { question: "What is the output of the following program?\n#include <stdio.h>\nbool func(int arr[], int n, int sum)\n{\nif (sum == 0)\nreturn true;\nif (n == 0 && sum != 0)\nreturn false;\nif (arr[n-1] > sum)\nreturn func(arr, n-1, sum);\n\nreturn func(arr, n-1, sum) || func(arr, n-1, sum-arr[n-1]);\n}\nint main()\n{\nint arr[] = {4,6, 12, 2};\nint sum = 12;\nint n = sizeof(arr)/sizeof(arr[0]);\nif (func(arr, n, sum) == true)\nprintf(\"true\");\nelse\nprintf(\"false\");\nreturn 0;\n}", options: ["12", "4 6 2", "true", "false"], answer: "true" },
                    { question: "What is the output of the following program?\n#include <stdio.h>\nbool func(int arr[], int n, int sum)\n{\nbool subarr[n+1][sum+1];\nfor (int i = 0; i <= n; i++)\nsubarr[i][0] = true;\nfor (int i = 1; i <= sum; i++)\nsubarr[0][i] = false;\nfor (int i = 1; i <= n; i++)\n{\nfor (int j = 1; j <= sum; j++)\n{\nif(j<arr[i-1])\nsubarr[i][j] = subarr[i-1][j];\nif (j >= arr[i-1])\nsubarr[i][j] = subarr[i-1][j] || subarr[i - 1][j-arr[i-1]];\n}\n}\nreturn subarr[n][sum];\n}\nint main()\n{\nint arr[] = {3, 3, 4, 4, 7};\nint sum = 5;\nint n = sizeof(arr)/sizeof(arr[0]);\nif (func(arr, n, sum) == true)\nprintf(\"true\");\nelse\nprintf(\"false\");\nreturn 0;\n}", options: ["true", "false", "0", "error"], answer: "false" }
                ]
            },
            {
                category: "Longest Palindromic Subsequence (LPS)",
                items: [
                    { question: "What is the length of the longest palindromic subsequence for the string 'abdgkagdjbccbba'?", options: ["9", "7", "8", "10"], answer: "9" },
                    { question: "What is the time complexity of the brute force algorithm used to find the length of the longest palindromic subsequence?", options: ["O(1)", "O(n^2)", "O(n)", "O(2^n)"], answer: "O(2^n)" },
                    { question: "What is the length of the longest palindromic subsequence for the string 'ababcdabba'?", options: ["6", "7", "8", "9"], answer: "7" },
                    { question: "For which of the following, the length of the string is not equal to the length of the longest palindromic subsequence?", options: ["A string that is a palindrome", "A string of length one", "A string that has all the same letters (e.g., aaaaaa)", "Some strings of length two"], answer: "Some strings of length two" },
                    { question: "What is the length of the longest palindromic subsequence for the string 'abcd'?", options: ["2", "1", "3", "4"], answer: "1" },
                    { question: "Which of the following is not a palindromic subsequence of the string 'ababcdabba'?", options: ["abcba", "abba", "abbbba", "adba"], answer: "adba" },
                    { question: "Longest palindromic subsequence is an example of", options: ["Greedy algorithm", "2D dynamic programming", "1D dynamic programming", "Divide and conquer"], answer: "2D dynamic programming" },
                    { question: "Which of the following methods can be used to solve the longest palindromic subsequence problem?", options: ["Dynamic programming", "Recursion", "Brute force", "All of the above"], answer: "All of the above" },
                    { question: "For every non-empty string, the length of the longest palindromic subsequence is", options: ["at most one", "at least one", "one", "-1"], answer: "at least one" },
                    { question: "What is the length of the longest palindromic subsequence for the string 'aeiou'?", options: ["0", "1", "2", "3"], answer: "1" }
                ]
            },
            {
                category: "Types of Set",
                items: [
                    { question: "In Java, if you need a set implementation that guarantees constant-time performance for basic operations and allows for custom ordering of elements, which data structure would you choose, and why?", options: ["HashSet, because it offers constant-time performance and allows custom ordering.", "TreeSet, because it maintains elements in sorted order and provides logarithmic-time performance for basic operations.", "LinkedHashSet, because it preserves insertion order and offers constant-time performance for basic operations.", "ConcurrentHashMap, because it provides thread-safe access to a hash table of key-value pairs."], answer: "TreeSet, because it maintains elements in sorted order and provides logarithmic-time performance for basic operations." },
                    { question: "When would you choose to use a BitSet over other set implementations in Java, considering both performance and functionality?", options: ["When memory efficiency is a primary concern and bitwise operations on integer sets are required.", "When you need to maintain elements in sorted order and ensure constant-time performance for all operations.", "When you require thread-safe access to a set of elements in a concurrent environment.", "When you need to store elements with multiple occurrences while preserving insertion order."], answer: "When memory efficiency is a primary concern and bitwise operations on integer sets are required." },
                    { question: "Which implementation of Set in Java does not maintain the insertion order?", options: ["HashSet", "LinkedHashSet", "TreeSet", "EnumSet"], answer: "HashSet" },
                    { question: "Which Set implementation in Java provides predictable iteration order?", options: ["TreeSet", "HashSet", "EnumSet", "LinkedHashSet"], answer: "LinkedHashSet" },
                    { question: "What will be the output of the following Java code snippet?\nSet<Integer> set = new HashSet<>();\nset.add(1);\nset.add(2);\nset.add(3);\nset.remove(2);\nSystem.out.println(set.size());", options: ["2", "3", "1", "Compilation Error"], answer: "2" },
                    { question: "What does the following Java code snippet do?\nSet<String> set = new TreeSet<>();\nset.add(\"banana\");\nset.add(\"apple\");\nset.add(\"orange\");", options: ["Inserts elements into a HashSet", "Inserts elements into a TreeSet and sorts them", "Inserts elements into a LinkedHashSet", "Compilation Error"], answer: "Inserts elements into a TreeSet and sorts them" },
                    { question: "Which of the following methods is used to create an immutable Set in Java?", options: ["unmodifiableSet() method in the Collections class", "immutableSet() method in the Set interface", "makeImmutable() method in the Set interface", "freeze() method in the Set interface"], answer: "unmodifiableSet() method in the Collections class" },
                    { question: "What is the purpose of the ceiling() method in the TreeSet class?", options: ["It returns the smallest element in the set that is greater than or equal to the specified element.", "It returns the largest element in the set that is smaller than or equal to the specified element.", "It returns the smallest element in the set that is strictly greater than the specified element.", "It returns the largest element in the set that is strictly smaller than the specified element."], answer: "It returns the smallest element in the set that is greater than or equal to the specified element." },
                    { question: "Which of the following statements is true about the elements() method in the NavigableSet interface?", options: ["It returns a view of the set in ascending order.", "It returns a view of the set in descending order.", "It returns a view of the set in the order of insertion.", "It returns a view of the set in random order."], answer: "It returns a view of the set in ascending order." },
                    { question: "What is the time complexity of the contains() method in the HashSet class in Java?", options: ["O(n)", "O(n log n)", "O(1)", "O(log n)"], answer: "O(1)" },
                    { question: "Which of the following statements is true about the removeAll() method in the Set interface?", options: ["It removes all elements from the set.", "It removes all elements from the set that are present in the specified collection.", "It removes all elements from the set that are not present in the specified collection.", "It removes only the first occurrence of the specified element from the set."], answer: "It removes all elements from the set that are present in the specified collection." }
                ]
            },
            {
                category: "Input/Output Based Questions",
                items: [
                    { 
                        question: "What is the output of the following code?\n```\nfunction findLoop(head) {\n  let slow = head;\n  let fast = head;\n  \n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    \n    if (slow === fast) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n```\nGiven a linked list with a loop starting at the 3rd node.", 
                        options: ["true", "false", "undefined", "Error"], 
                        answer: "true" 
                    },
                    { 
                        question: "What is the output of the following code?\n```\nfunction sortBitonicDLL(head) {\n  if (!head || !head.next) return head;\n  \n  let ascending = head;\n  let descending = null;\n  let current = head;\n  \n  while (current.next && current.data <= current.next.data) {\n    current = current.next;\n  }\n  \n  if (current.next) {\n    descending = current.next;\n    current.next = null;\n    descending.prev = null;\n  }\n  \n  return merge(ascending, reverse(descending));\n}\n```\nGiven a bitonic DLL: 13510864", 
                        options: ["13456810", "10865431", "13510468", "13546810"], 
                        answer: "13456810" 
                    },
                    { 
                        question: "What is the output of the following code?\n```\nfunction segregateEvenOdd(head) {\n  if (!head || !head.next) return head;\n  \n  let evenStart = null, evenEnd = null;\n  let oddStart = null, oddEnd = null;\n  let current = head;\n  \n  while (current) {\n    if (current.data % 2 === 0) {\n      if (!evenStart) {\n        evenStart = current;\n        evenEnd = current;\n      } else {\n        evenEnd.next = current;\n        evenEnd = current;\n      }\n    } else {\n      if (!oddStart) {\n        oddStart = current;\n        oddEnd = current;\n      } else {\n        oddEnd.next = current;\n        oddEnd = current;\n      }\n    }\n    current = current.next;\n  }\n  \n  if (!evenStart) return oddStart;\n  if (!oddStart) return evenStart;\n  \n  evenEnd.next = oddStart;\n  oddEnd.next = null;\n  \n  return evenStart;\n}\n```\nGiven a linked list: 12345", 
                        options: ["24135", "13524", "12345", "53142"], 
                        answer: "24135" 
                    },
                    { 
                        question: "What is the output of the following code?\n```\nclass MinStack {\n  constructor() {\n    this.stack = [];\n    this.minStack = [];\n  }\n  \n  push(val) {\n    this.stack.push(val);\n    \n    if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {\n      this.minStack.push(val);\n    }\n  }\n  \n  pop() {\n    if (this.stack.length === 0) return null;\n    \n    const val = this.stack.pop();\n    \n    if (val === this.minStack[this.minStack.length - 1]) {\n      this.minStack.pop();\n    }\n    \n    return val;\n  }\n  \n  top() {\n    if (this.stack.length === 0) return null;\n    return this.stack[this.stack.length - 1];\n  }\n  \n  getMin() {\n    if (this.minStack.length === 0) return null;\n    return this.minStack[this.minStack.length - 1];\n  }\n}\n\nconst stack = new MinStack();\nstack.push(5);\nstack.push(2);\nstack.push(4);\nstack.push(1);\nstack.push(3);\nstack.pop();\nstack.pop();\nconsole.log(stack.getMin());\n```", 
                        options: ["1", "2", "3", "5"], 
                        answer: "2" 
                    },
                    { 
                        question: "What is the output of the following code?\n```\nfunction findCelebrity(n, knows) {\n  let candidate = 0;\n  \n  for (let i = 1; i < n; i++) {\n    if (knows(candidate, i)) {\n      candidate = i;\n    }\n  }\n  \n  for (let i = 0; i < n; i++) {\n    if (i !== candidate && (knows(candidate, i) || !knows(i, candidate))) {\n      return -1;\n    }\n  }\n  \n  return candidate;\n}\n\nconst knows = (a, b) => {\n  const matrix = [\n    [0, 1, 0, 0],\n    [0, 0, 0, 0],\n    [1, 1, 0, 0],\n    [1, 1, 1, 0]\n  ];\n  return matrix[a][b] === 1;\n};\n\nconsole.log(findCelebrity(4, knows));\n```", 
                        options: ["0", "1", "2", "3"], 
                        answer: "1" 
                    },
                    { 
                        question: "What is the output of the following code?\n```\nfunction towerOfHanoi(n) {\n  const moves = [];\n  const towers = [[], [], []];\n  \n  // Initialize tower A with disks\n  for (let i = n; i > 0; i--) {\n    towers[0].push(i);\n  }\n  \n  const totalMoves = Math.pow(2, n) - 1;\n  \n  for (let i = 1; i <= totalMoves; i++) {\n    if (i % 3 === 1) {\n      moveDisk(towers, 0, 2, moves);\n    } else if (i % 3 === 2) {\n      moveDisk(towers, 0, 1, moves);\n    } else {\n      moveDisk(towers, 1, 2, moves);\n    }\n  }\n  \n  return moves.length;\n}\n\nfunction moveDisk(towers, from, to, moves) {\n  if (towers[from].length === 0) {\n    [from, to] = [to, from];\n  }\n  \n  if (towers[to].length === 0 || towers[from][towers[from].length - 1] < towers[to][towers[to].length - 1]) {\n    const disk = towers[from].pop();\n    towers[to].push(disk);\n    moves.push([from, to]);\n  } else {\n    const disk = towers[to].pop();\n    towers[from].push(disk);\n    moves.push([to, from]);\n  }\n}\n\nconsole.log(towerOfHanoi(3));\n```", 
                        options: ["5", "7", "8", "15"], 
                        answer: "7" 
                    },
                    { 
                        question: "What is the output of the following code?\n```\nfunction calculateStockSpan(prices) {\n  const n = prices.length;\n  const spans = new Array(n).fill(1);\n  const stack = [];\n  \n  for (let i = 0; i < n; i++) {\n    while (stack.length > 0 && prices[stack[stack.length - 1]] <= prices[i]) {\n      stack.pop();\n    }\n    \n    spans[i] = stack.length === 0 ? i + 1 : i - stack[stack.length - 1];\n    stack.push(i);\n  }\n  \n  return spans;\n}\n\nconsole.log(calculateStockSpan([100, 80, 60, 70, 60, 75, 85]));\n```", 
                        options: ["[1, 1, 1, 2, 1, 4, 6]", "[1, 1, 1, 2, 1, 4, 5]", "[1, 1, 1, 2, 1, 3, 6]", "[1, 1, 1, 2, 1, 3, 5]"], 
                        answer: "[1, 1, 1, 2, 1, 4, 6]" 
                    },
                    { 
                        question: "What is the output of the following code?\n```\nfunction maxSlidingWindow(nums, k) {\n  const result = [];\n  const deque = [];\n  \n  for (let i = 0; i < nums.length; i++) {\n    // Remove elements outside the window\n    while (deque.length > 0 && deque[0] < i - k + 1) {\n      deque.shift();\n    }\n    \n    // Remove smaller elements\n    while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {\n      deque.pop();\n    }\n    \n    deque.push(i);\n    \n    if (i >= k - 1) {\n      result.push(nums[deque[0]]);\n    }\n  }\n  \n  return result;\n}\n\nconsole.log(maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3));\n```", 
                        options: ["[3, 3, 5, 5, 6, 7]", "[1, 3, -1, 5, 5, 6]", "[3, 3, -1, 5, 5, 7]", "[1, 3, 5, 5, 6, 7]"], 
                        answer: "[3, 3, 5, 5, 6, 7]" 
                    },
                    { 
                        question: "What is the output of the following code?\n```\nfunction isStackPermutation(input, output) {\n  const stack = [];\n  let j = 0;\n  \n  for (let i = 0; i < input.length; i++) {\n    stack.push(input[i]);\n    \n    while (stack.length > 0 && stack[stack.length - 1] === output[j]) {\n      stack.pop();\n      j++;\n    }\n  }\n  \n  return stack.length === 0;\n}\n\nconsole.log(isStackPermutation([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]));\nconsole.log(isStackPermutation([1, 2, 3, 4, 5], [4, 5, 3, 2, 1]));\n```", 
                        options: ["true, true", "true, false", "false, true", "false, false"], 
                        answer: "true, true" 
                    },
                    { 
                        question: "What is the output of the following code?\n```\nfunction reverseLinkedList(head) {\n  let prev = null;\n  let current = head;\n  let next = null;\n  \n  while (current) {\n    next = current.next;\n    current.next = prev;\n    prev = current;\n    current = next;\n  }\n  \n  return prev;\n}\n\nfunction printList(head) {\n  const values = [];\n  let current = head;\n  \n  while (current) {\n    values.push(current.data);\n    current = current.next;\n  }\n  \n  return values.join('');\n}\n\nclass Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\nconst head = new Node(1);\nhead.next = new Node(2);\nhead.next.next = new Node(3);\nhead.next.next.next = new Node(4);\nhead.next.next.next.next = new Node(5);\n\nconsole.log(printList(reverseLinkedList(head)));\n```", 
                        options: ["12345", "54321", "51234", "15432"], 
                        answer: "54321" 
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction mergeSortDLL(head) {\n  if (!head || !head.next) return head;\n  \n  let slow = head, fast = head.next;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  \n  let second = slow.next;\n  slow.next = null;\n  second.prev = null;\n  \n  return merge(mergeSortDLL(head), mergeSortDLL(second));\n}\n```\nGiven a doubly linked list: 93715",
                        options: ["13579", "97531", "31579", "93715"],
                        answer: "13579"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction priorityQueueInsert(queue, val, priority) {\n  queue.push({ val, priority });\n  queue.sort((a, b) => b.priority - a.priority);\n}\nfunction priorityQueueDeleteMax(queue) {\n  return queue.shift()?.val;\n}\nconst queue = [];\npriorityQueueInsert(queue, 'A', 3);\npriorityQueueInsert(queue, 'B', 1);\npriorityQueueInsert(queue, 'C', 5);\nconsole.log(priorityQueueDeleteMax(queue));\n```",
                        options: ["A", "B", "C", "undefined"],
                        answer: "C"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction quickSort(arr, low, high) {\n  if (low < high) {\n    let pi = partition(arr, low, high);\n    quickSort(arr, low, pi - 1);\n    quickSort(arr, pi + 1, high);\n  }\n  return arr;\n}\nfunction partition(arr, low, high) {\n  let pivot = arr[high];\n  let i = low - 1;\n  for (let j = low; j < high; j++) {\n    if (arr[j] <= pivot) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n  return i + 1;\n}\nconsole.log(quickSort([5, 2, 9, 1, 7], 0, 4));\n```",
                        options: ["[1, 2, 5, 7, 9]", "[5, 2, 9, 1, 7]", "[9, 7, 5, 2, 1]", "[2, 1, 5, 7, 9]"],
                        answer: "[1, 2, 5, 7, 9]"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction findLoopLength(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) {\n      let length = 1;\n      slow = slow.next;\n      while (slow !== fast) {\n        slow = slow.next;\n        length++;\n      }\n      return length;\n    }\n  }\n  return 0;\n}\n```\nGiven a linked list: 123453 (loops back to 3)",
                        options: ["0", "2", "3", "5"],
                        answer: "3"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction bitonicSplit(head) {\n  let current = head;\n  while (current.next && current.data < current.next.data) {\n    current = current.next;\n  }\n  return current.data;\n}\n```\nGiven a bitonic DLL: 246531",
                        options: ["2", "4", "5", "6"],
                        answer: "6"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction segregateEvenOddEnd(head) {\n  let even = [], odd = [];\n  let current = head;\n  while (current) {\n    if (current.data % 2 === 0) even.push(current.data);\n    else odd.push(current.data);\n    current = current.next;\n  }\n  return [...even, ...odd].join('');\n}\n```\nGiven a linked list: 7891011",
                        options: ["8107911", "7911810", "8107911", "7891011"],
                        answer: "8107911"
                    },
                    {
                        question: "What is the output of the following code?\n```\nclass MinStack {\n  constructor() {\n    this.stack = [];\n    this.minStack = [];\n  }\n  push(val) {\n    this.stack.push(val);\n    if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {\n      this.minStack.push(val);\n    }\n  }\n  pop() {\n    if (this.stack.length === 0) return null;\n    let val = this.stack.pop();\n    if (val === this.minStack[this.minStack.length - 1]) this.minStack.pop();\n    return val;\n  }\n  getMin() {\n    return this.minStack[this.minStack.length - 1];\n  }\n}\nconst stack = new MinStack();\nstack.push(3);\nstack.push(5);\nstack.pop();\nconsole.log(stack.getMin());\n```",
                        options: ["3", "5", "null", "undefined"],
                        answer: "3"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction findCelebrity(n, knows) {\n  let candidate = 0;\n  for (let i = 1; i < n; i++) {\n    if (knows(candidate, i)) candidate = i;\n  }\n  for (let i = 0; i < n; i++) {\n    if (i !== candidate && (knows(candidate, i) || !knows(i, candidate))) return -1;\n  }\n  return candidate;\n}\nconst knows = (a, b) => {\n  const matrix = [\n    [0, 1, 1],\n    [0, 0, 1],\n    [0, 0, 0]\n  ];\n  return matrix[a][b] === 1;\n};\nconsole.log(findCelebrity(3, knows));\n```",
                        options: ["0", "1", "2", "-1"],
                        answer: "2"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction towerOfHanoiMoves(n) {\n  return Math.pow(2, n) - 1;\n}\nconsole.log(towerOfHanoiMoves(4));\n```",
                        options: ["7", "15", "31", "63"],
                        answer: "15"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction stockSpanFirstDay(prices) {\n  const spans = new Array(prices.length).fill(1);\n  const stack = [];\n  for (let i = 0; i < prices.length; i++) {\n    while (stack.length > 0 && prices[stack[stack.length - 1]] <= prices[i]) {\n      stack.pop();\n    }\n    spans[i] = stack.length === 0 ? i + 1 : i - stack[stack.length - 1];\n    stack.push(i);\n  }\n  return spans[0];\n}\nconsole.log(stockSpanFirstDay([50, 30, 20, 40, 60]));\n```",
                        options: ["1", "2", "3", "5"],
                        answer: "1"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction maxSlidingWindowLast(nums, k) {\n  const result = [];\n  const deque = [];\n  for (let i = 0; i < nums.length; i++) {\n    while (deque.length > 0 && deque[0] < i - k + 1) deque.shift();\n    while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) deque.pop();\n    deque.push(i);\n    if (i >= k - 1) result.push(nums[deque[0]]);\n  }\n  return result[result.length - 1];\n}\nconsole.log(maxSlidingWindowLast([2, 4, 1, 3, 5, 6], 3));\n```",
                        options: ["1", "3", "5", "6"],
                        answer: "6"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction isStackPermutationSingle(input, output) {\n  const stack = [];\n  let j = 0;\n  for (let i = 0; i < input.length; i++) {\n    stack.push(input[i]);\n    while (stack.length > 0 && stack[stack.length - 1] === output[j]) {\n      stack.pop();\n      j++;\n    }\n  }\n  return stack.length === 0;\n}\nconsole.log(isStackPermutationSingle([1, 2, 3], [2, 1, 3]));\n```",
                        options: ["true", "false", "undefined", "Error"],
                        answer: "false"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction deleteMiddle(head) {\n  if (!head || !head.next) return null;\n  let slow = head, fast = head, prev = null;\n  while (fast && fast.next) {\n    prev = slow;\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  prev.next = slow.next;\n  return head;\n}\nfunction printList(head) {\n  const values = [];\n  let current = head;\n  while (current) {\n    values.push(current.data);\n    current = current.next;\n  }\n  return values.join('');\n}\nclass Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\nconst head = new Node(1);\nhead.next = new Node(2);\nhead.next.next = new Node(3);\nhead.next.next.next = new Node(4);\nconsole.log(printList(deleteMiddle(head)));\n```",
                        options: ["124", "134", "123", "234"],
                        answer: "124"
                    },
                    {
                        question: "What is the output of the following code?\n```\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n  push(val) {\n    this.items.push(val);\n  }\n  pop() {\n    return this.items.pop();\n  }\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n}\nconst stack = new Stack();\nstack.push(1);\nstack.push(2);\nstack.push(3);\nstack.pop();\nstack.push(4);\nconsole.log(stack.peek());\n```",
                        options: ["1", "2", "3", "4"],
                        answer: "4"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction mergeSortStep(arr) {\n  if (arr.length <= 1) return arr;\n  const mid = Math.floor(arr.length / 2);\n  return [arr.slice(0, mid), arr.slice(mid)];\n}\nconsole.log(mergeSortStep([8, 3, 5, 1, 7]));\n```",
                        options: ["[[8, 3], [5, 1, 7]]", "[[8, 3, 5], [1, 7]]", "[[8], [3, 5, 1, 7]]", "[[8, 3, 5, 1], [7]]"],
                        answer: "[[8, 3], [5, 1, 7]]"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction detectLoopStart(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) {\n      slow = head;\n      while (slow !== fast) {\n        slow = slow.next;\n        fast = fast.next;\n      }\n      return slow.data;\n    }\n  }\n  return -1;\n}\n```\nGiven a linked list: 123452 (loops back to 2)",
                        options: ["1", "2", "3", "-1"],
                        answer: "2"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction bitonicReverse(head) {\n  let current = head;\n  while (current.next && current.data < current.next.data) {\n    current = current.next;\n  }\n  let descending = current.next;\n  let result = [];\n  while (descending) {\n    result.push(descending.data);\n    descending = descending.next;\n  }\n  return result.join('');\n}\n```\nGiven a bitonic DLL: 13542",
                        options: ["42", "542", "24", "135"],
                        answer: "42"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction segregateEvenOddCount(head) {\n  let even = 0, odd = 0;\n  let current = head;\n  while (current) {\n    if (current.data % 2 === 0) even++;\n    else odd++;\n    current = current.next;\n  }\n  return even;\n}\n```\nGiven a linked list: 23456",
                        options: ["2", "3", "4", "5"],
                        answer: "3"
                    },
                    {
                        question: "What is the output of the following code?\n```\nclass MinStack {\n  constructor() {\n    this.stack = [];\n    this.minStack = [];\n  }\n  push(val) {\n    this.stack.push(val);\n    if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {\n      this.minStack.push(val);\n    }\n  }\n  pop() {\n    if (this.stack.length === 0) return null;\n    let val = this.stack.pop();\n    if (val === this.minStack[this.minStack.length - 1]) this.minStack.pop();\n    return val;\n  }\n  top() {\n    return this.stack[this.stack.length - 1];\n  }\n}\nconst stack = new MinStack();\nstack.push(4);\nstack.push(2);\nstack.push(6);\nconsole.log(stack.top());\n```",
                        options: ["2", "4", "6", "null"],
                        answer: "6"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction findCelebrityCount(n, knows) {\n  let candidate = 0;\n  for (let i = 1; i < n; i++) {\n    if (knows(candidate, i)) candidate = i;\n  }\n  let knownBy = 0;\n  for (let i = 0; i < n; i++) {\n    if (i !== candidate && knows(i, candidate)) knownBy++;\n  }\n  return knownBy;\n}\nconst knows = (a, b) => {\n  const matrix = [\n    [0, 1, 0],\n    [1, 0, 0],\n    [1, 1, 0]\n  ];\n  return matrix[a][b] === 1;\n};\nconsole.log(findCelebrityCount(3, knows));\n```",
                        options: ["0", "1", "2", "3"],
                        answer: "2"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction towerOfHanoiFirstMove(n) {\n  const moves = [];\n  const towers = [[], [], []];\n  for (let i = n; i > 0; i--) towers[0].push(i);\n  moveDisk(towers, 0, 1, moves);\n  return moves[0] ? `${moves[0][0]}${moves[0][1]}` : 'No move';\n}\nfunction moveDisk(towers, from, to, moves) {\n  if (towers[from].length === 0) return;\n  const disk = towers[from].pop();\n  towers[to].push(disk);\n  moves.push([from, to]);\n}\nconsole.log(towerOfHanoiFirstMove(2));\n```",
                        options: ["01", "02", "12", "No move"],
                        answer: "01"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction stockSpanLastDay(prices) {\n  const spans = new Array(prices.length).fill(1);\n  const stack = [];\n  for (let i = 0; i < prices.length; i++) {\n    while (stack.length > 0 && prices[stack[stack.length - 1]] <= prices[i]) {\n      stack.pop();\n    }\n    spans[i] = stack.length === 0 ? i + 1 : i - stack[stack.length - 1];\n    stack.push(i);\n  }\n  return spans[spans.length - 1];\n}\nconsole.log(stockSpanLastDay([10, 20, 30, 40]));\n```",
                        options: ["1", "2", "3", "4"],
                        answer: "4"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction maxSlidingWindowFirst(nums, k) {\n  const result = [];\n  const deque = [];\n  for (let i = 0; i < nums.length; i++) {\n    while (deque.length > 0 && deque[0] < i - k + 1) deque.shift();\n    while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) deque.pop();\n    deque.push(i);\n    if (i >= k - 1) result.push(nums[deque[0]]);\n  }\n  return result[0];\n}\nconsole.log(maxSlidingWindowFirst([5, 2, 8, 1, 9], 3));\n```",
                        options: ["2", "5", "8", "9"],
                        answer: "8"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction stackPermutationCount(input, output) {\n  const stack = [];\n  let j = 0, pushes = 0;\n  for (let i = 0; i < input.length; i++) {\n    stack.push(input[i]);\n    pushes++;\n    while (stack.length > 0 && stack[stack.length - 1] === output[j]) {\n      stack.pop();\n      j++;\n    }\n  }\n  return pushes;\n}\nconsole.log(stackPermutationCount([1, 2, 3], [3, 2, 1]));\n```",
                        options: ["1", "2", "3", "4"],
                        answer: "3"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction addNodeAtEnd(head, data) {\n  const newNode = { data, next: null };\n  if (!head) return newNode;\n  let current = head;\n  while (current.next) current = current.next;\n  current.next = newNode;\n  return head;\n}\nfunction printList(head) {\n  const values = [];\n  let current = head;\n  while (current) {\n    values.push(current.data);\n    current = current.next;\n  }\n  return values.join('');\n}\nlet head = { data: 1, next: { data: 2, next: null } };\nhead = addNodeAtEnd(head, 3);\nconsole.log(printList(head));\n```",
                        options: ["123", "132", "312", "213"],
                        answer: "123"
                    },
                    {
                        question: "What is the output of the following code?\n```\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n  push(val) {\n    this.items.push(val);\n  }\n  pop() {\n    return this.items.pop();\n  }\n}\nconst stack = new Stack();\nstack.push(5);\nstack.push(3);\nstack.pop();\nstack.push(7);\nstack.pop();\nconsole.log(stack.items);\n```",
                        options: ["[5]", "[3]", "[7]", "[5, 3]"],
                        answer: "[5]"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction mergeDLLFirst(head1, head2) {\n  if (!head1) return head2;\n  if (!head2) return head1;\n  if (head1.data <= head2.data) return head1;\n  return head2;\n}\nconst head1 = { data: 2, next: null };\nconst head2 = { data: 4, next: null };\nconsole.log(mergeDLLFirst(head1, head2).data);\n```",
                        options: ["2", "4", "null", "undefined"],
                        answer: "2"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction loopIntersection(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n  }\n  return false;\n}\n```\nGiven a linked list: 1234NULL",
                        options: ["true", "false", "undefined", "Error"],
                        answer: "false"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction bitonicPeak(head) {\n  let current = head;\n  while (current.next && current.data <= current.next.data) {\n    current = current.next;\n  }\n  return current.data;\n}\n```\nGiven a bitonic DLL: 1234321",
                        options: ["1", "2", "3", "4"],
                        answer: "4"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction segregateEvenOddFirst(head) {\n  let current = head;\n  while (current && current.data % 2 !== 0) {\n    current = current.next;\n  }\n  return current ? current.data : -1;\n}\n```\nGiven a linked list: 13524",
                        options: ["1", "2", "4", "-1"],
                        answer: "2"
                    },
                    {
                        question: "What is the output of the following code?\n```\nclass MinStack {\n  constructor() {\n    this.stack = [];\n    this.minStack = [];\n  }\n  push(val) {\n    this.stack.push(val);\n    if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {\n      this.minStack.push(val);\n    }\n  }\n  pop() {\n    if (this.stack.length === 0) return null;\n    let val = this.stack.pop();\n    if (val === this.minStack[this.minStack.length - 1]) this.minStack.pop();\n    return val;\n  }\n  getMin() {\n    return this.minStack[this.minStack.length - 1];\n  }\n}\nconst stack = new MinStack();\nstack.push(7);\nstack.push(3);\nstack.push(5);\nstack.pop();\nstack.pop();\nconsole.log(stack.getMin());\n```",
                        options: ["3", "5", "7", "null"],
                        answer: "7"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction findCelebrityKnown(n, knows) {\n  let candidate = 0;\n  for (let i = 1; i < n; i++) {\n    if (knows(candidate, i)) candidate = i;\n  }\n  let knowsOthers = 0;\n  for (let i = 0; i < n; i++) {\n    if (i !== candidate && knows(candidate, i)) knowsOthers++;\n  }\n  return knowsOthers;\n}\nconst knows = (a, b) => {\n  const matrix = [\n    [0, 1, 0],\n    [0, 0, 0],\n    [1, 1, 0]\n  ];\n  return matrix[a][b] === 1;\n};\nconsole.log(findCelebrityKnown(3, knows));\n```",
                        options: ["0", "1", "2", "3"],
                        answer: "0"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction towerOfHanoiDisks(n) {\n  const towers = [[], [], []];\n  for (let i = n; i > 0; i--) towers[0].push(i);\n  return towers[0].length;\n}\nconsole.log(towerOfHanoiDisks(3));\n```",
                        options: ["1", "2", "3", "4"],
                        answer: "3"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction stockSpanSecondDay(prices) {\n  const spans = new Array(prices.length).fill(1);\n  const stack = [];\n  for (let i = 0; i < prices.length; i++) {\n    while (stack.length > 0 && prices[stack[stack.length - 1]] <= prices[i]) {\n      stack.pop();\n    }\n    spans[i] = stack.length === 0 ? i + 1 : i - stack[stack.length - 1];\n    stack.push(i);\n  }\n  return spans[1];\n}\nconsole.log(stockSpanSecondDay([100, 80, 60, 70]));\n```",
                        options: ["1", "2", "3", "4"],
                        answer: "1"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction maxSlidingWindowSecond(nums, k) {\n  const result = [];\n  const deque = [];\n  for (let i = 0; i < nums.length; i++) {\n    while (deque.length > 0 && deque[0] < i - k + 1) deque.shift();\n    while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) deque.pop();\n    deque.push(i);\n    if (i >= k - 1) result.push(nums[deque[0]]);\n  }\n  return result[1];\n}\nconsole.log(maxSlidingWindowSecond([1, 3, -1, -3, 5], 3));\n```",
                        options: ["1", "3", "-1", "-3"],
                        answer: "3"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction stackPermutationPops(input, output) {\n  const stack = [];\n  let j = 0, pops = 0;\n  for (let i = 0; i < input.length; i++) {\n    stack.push(input[i]);\n    while (stack.length > 0 && stack[stack.length - 1] === output[j]) {\n      stack.pop();\n      j++;\n      pops++;\n    }\n  }\n  return pops;\n}\nconsole.log(stackPermutationPops([1, 2, 3], [3, 2, 1]));\n```",
                        options: ["1", "2", "3", "4"],
                        answer: "3"
                    },
                    {
                        question: "What is the output of the following code?\n```\nfunction addNodeAtStart(head, data) {\n  const newNode = { data, next: head };\n  return newNode;\n}\nfunction printList(head) {\n  const values = [];\n  let current = head;\n  while (current) {\n    values.push(current.data);\n    current = current.next;\n  }\n  return values.join('');\n}\nlet head = { data: 2, next: { data: 3, next: null } };\nhead = addNodeAtStart(head, 1);\nconsole.log(printList(head));\n```",
                        options: ["123", "231", "321", "132"],
                        answer: "123"
                    },
                    {
                        question: "What is the output of the following code?\n```\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n  push(val) {\n    this.items.push(val);\n  }\n  pop() {\n    return this.items.pop();\n  }\n}\nconst stack = new Stack();\nstack.push(1);\nstack.push(2);\nstack.pop();\nstack.pop();\nconsole.log(stack.items.length);\n```",
                        options: ["0", "1", "2", "3"],
                        answer: "0"
                    }
                    
                ]
            
            }
        ];

        const Quiz = () => {
            const [selectedCategory, setSelectedCategory] = React.useState(null);
            const [currentCategoryIndex, setCurrentCategoryIndex] = React.useState(0);
            const [currentQuestionIndex, setCurrentQuestionIndex] = React.useState(0);
            const [selectedOption, setSelectedOption] = React.useState(null);
            const [score, setScore] = React.useState(0);
            const [showResult, setShowResult] = React.useState(false);
            const [answered, setAnswered] = React.useState(false);
            const [filteredQuestions, setFilteredQuestions] = React.useState(questions);
            const [shuffledQuestions, setShuffledQuestions] = React.useState([]);

            // Function to shuffle array (Fisher-Yates algorithm)
            const shuffleArray = (array) => {
                const newArray = [...array];
                for (let i = newArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                }
                return newArray;
            };

            const handleCategorySelect = (category) => {
                if (category === "Full Quiz") {
                    // For full quiz, we'll shuffle all questions from all categories
                    const allQuestions = [];
                    questions.forEach(category => {
                        category.items.forEach(question => {
                            allQuestions.push({
                                ...question,
                                categoryName: category.category
                            });
                        });
                    });
                    
                    const shuffled = shuffleArray(allQuestions);
                    setShuffledQuestions(shuffled);
                    setFilteredQuestions([{ category: "Full Quiz", items: shuffled }]);
                    setCurrentCategoryIndex(0);
                } else {
                    const filtered = questions.filter(q => q.category === category);
                    setFilteredQuestions(filtered);
                    setCurrentCategoryIndex(0);
                    setShuffledQuestions([]);
                }
                setSelectedCategory(category);
                setCurrentQuestionIndex(0);
                setScore(0);
                setShowResult(false);
                setAnswered(false);
                setSelectedOption(null);
            };

            const currentCategory = filteredQuestions[currentCategoryIndex];
            const currentQuestion = currentCategory?.items[currentQuestionIndex];

            const handleOptionSelect = (option) => {
                if (!answered) {
                    setSelectedOption(option);
                    setAnswered(true);
                    if (option === currentQuestion.answer) {
                        setScore(score + 1);
                    }
                }
            };

            const handleNext = () => {
                if (currentQuestionIndex + 1 < currentCategory.items.length) {
                    setCurrentQuestionIndex(currentQuestionIndex + 1);
                } else if (currentCategoryIndex + 1 < filteredQuestions.length) {
                    setCurrentCategoryIndex(currentCategoryIndex + 1);
                    setCurrentQuestionIndex(0);
                } else {
                    setShowResult(true);
                }
                setSelectedOption(null);
                setAnswered(false);
            };

            const handleRestart = () => {
                if (selectedCategory === "Full Quiz") {
                    // Reshuffle questions for a new full quiz
                    const allQuestions = [];
                    questions.forEach(category => {
                        category.items.forEach(question => {
                            allQuestions.push({
                                ...question,
                                categoryName: category.category
                            });
                        });
                    });
                    
                    const shuffled = shuffleArray(allQuestions);
                    setShuffledQuestions(shuffled);
                    setFilteredQuestions([{ category: "Full Quiz", items: shuffled }]);
                }
                setCurrentCategoryIndex(0);
                setCurrentQuestionIndex(0);
                setSelectedOption(null);
                setScore(0);
                setShowResult(false);
                setAnswered(false);
            };

            const totalQuestions = filteredQuestions.reduce((sum, category) => sum + category.items.length, 0);

            if (!selectedCategory) {
                return (
                    <div className="bg-white p-8 rounded-xl shadow-2xl w-full max-w-3xl">
                        <h1 className="text-3xl font-bold text-center text-blue-600 mb-6">Data Structures Quiz</h1>
                        <p className="text-center text-gray-600 mb-8">Choose a category to start the quiz or take the full quiz!</p>
                        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            {questions.map((category, index) => (
                                <button
                                    key={index}
                                    onClick={() => handleCategorySelect(category.category)}
                                    className="bg-blue-500 text-white px-4 py-3 rounded-lg hover:bg-blue-600 transition-all duration-300 shadow-md"
                                >
                                    {category.category}
                                </button>
                            ))}
                            <button
                                onClick={() => handleCategorySelect("Full Quiz")}
                                className="bg-purple-500 text-white px-4 py-3 rounded-lg hover:bg-purple-600 transition-all duration-300 shadow-md sm:col-span-2"
                            >
                                Full Quiz
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="bg-white p-8 rounded-xl shadow-2xl w-full max-w-3xl">
                    {showResult ? (
                        <div className="text-center">
                            <h2 className="text-3xl font-bold text-blue-600 mb-4">Quiz Completed!</h2>
                            <p className="text-lg text-gray-700 mb-4">Your Score: {score} / {totalQuestions}</p>
                            <div className="flex justify-center space-x-4">
                                <button
                                    onClick={handleRestart}
                                    className="bg-blue-500 text-white px-6 py-2 rounded-lg hover:bg-blue-600 transition-all duration-300 shadow-md"
                                >
                                    Restart Quiz
                                </button>
                                <button
                                    onClick={() => setSelectedCategory(null)}
                                    className="bg-gray-500 text-white px-6 py-2 rounded-lg hover:bg-gray-600 transition-all duration-300 shadow-md"
                                >
                                    Back to Categories
                                </button>
                            </div>
                        </div>
                    ) : (
                        <div>
                            <h2 className="text-2xl font-bold text-blue-600 mb-4">
                                {selectedCategory === "Full Quiz" && currentQuestion.categoryName 
                                    ? `${currentQuestion.categoryName}` 
                                    : currentCategory.category}
                            </h2>
                            <p className="text-sm text-gray-600 mb-4">
                                Question {currentQuestionIndex + 1} of {currentCategory.items.length}
                            </p>
                            <div className="text-lg font-medium text-gray-800 mb-6 whitespace-pre-wrap">
                                {currentQuestion.question}
                            </div>
                            <div className="space-y-3">
                                {currentQuestion.options.map((option, index) => (
                                    <button
                                        key={index}
                                        onClick={() => handleOptionSelect(option)}
                                        className={`w-full text-left p-4 rounded-lg border-2 transition-all duration-300 ${
                                            selectedOption === option
                                                ? answered && option === currentQuestion.answer
                                                    ? 'bg-green-100 border-green-500 text-green-700'
                                                    : answered
                                                    ? 'bg-red-100 border-red-500 text-red-700'
                                                    : 'bg-gray-100 border-gray-300'
                                                : answered && option === currentQuestion.answer
                                                    ? 'bg-green-100 border-green-500 text-green-700'
                                                    : 'bg-gray-100 border-gray-300 hover:bg-gray-200'
                                        }`}
                                        disabled={answered}
                                    >
                                        {option}
                                    </button>
                                ))}
                            </div>
                            {answered && (
                                <div className="mt-4">
                                    {selectedOption === currentQuestion.answer ? (
                                        <p className="text-green-600 font-medium">Correct!</p>
                                    ) : (
                                        <p className="text-red-600 font-medium">
                                            Incorrect. The correct answer is: {currentQuestion.answer}
                                        </p>
                                    )}
                                </div>
                            )}
                            <button
                                onClick={handleNext}
                                className="mt-6 bg-blue-500 text-white px-6 py-2 rounded-lg hover:bg-blue-600 disabled:bg-gray-400 transition-all duration-300 shadow-md"
                                disabled={!answered}
                            >
                                Next
                            </button>
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.render(<Quiz />, document.getElementById('root'));
    </script>
</body>
</html>
